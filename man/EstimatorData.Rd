% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EstimatorData.R
\name{EstimatorData}
\alias{EstimatorData}
\title{checks and converts input data for Overlap-Estimators}
\usage{
EstimatorData(data1, data2, mindatapoints = 20, funcdatapoints = NULL,
  Interpolate = FALSE, onlyOverlap = FALSE)
}
\arguments{
\item{data1}{list: like returned by either the estdist() and uniform()functions or by the kernelest() and normalize() function.}

\item{data2}{list: like returned by either the estdist() and uniform()functions or by the kernelest() and normalize() function.}

\item{mindatapoints}{numeric(whole numbers); the minimum number of datapoints that both data share.}

\item{funcdatapoints}{numeric (whole numbers); determines how much datapoints shall be drawn from functions. only rough guideline, results may vary.}

\item{onlyOverlap}{logical; determines, whether the whole timerange shall be returned or just the time-range of the actual overlap-}

\item{interpolate}{logical; determines whether data should be interpolated linearly if one datapoin is missing in one dataset.}
}
\value{
list of two data.frames. Those represent the pdfs. Used to determine overlap.
}
\description{
checks and converts input data for Overlap-Estimators
}
\details{
provides the data used to calculate the overlap measure. It can handle dataframes and functions. First it determines , whether the data provided is a function or a dataframe. After this is done, it checks whether those functions are structured adequately for further calculation purposes (this is done by CheckProbData() or CheckProbFunc().) Those function make sure There are three possible initial combinations for data. Both given datasets are functions, only one is a function, or both are dataframes. If both are functions, it will create two dataframes, with equally distributed datapoints. To calculate the overlap it is necessary that the x values for the overlaprange are the same, which makes it impossible to give one specific number of datapoints for each particular functions, so the sum of all the x-values (of both functions) is twice the number of funcdatapoints. Those x-values are distributed equally on the range of both  functions. In the end those x-values will be cut to the range needed, so either the range in which both functions overlap (onlyOverap = TRUE) or the range of the respective function. To create the dataframe, those x values are combined with the belonging y-values of the given functions. The interpolate argument does not affect this type of calculation. If only one of the given data is a function (and the other accordingly a dataframe), and Interpolate is set FALSE, it will return the given dataframe and  create one, with one x-value for every day in the range of the function. If interpolate = TRUE it will do the same as for two functions, and get the missing  datapoints in the dataframe by interpolating linearly. If there are two dataframes and Interpolate is set FALSE it will return the dataframes with  the datapoints that both dataframes share in the overlaprange. If it is set TRUE it will get both dataframes to the same x- values by interpolating linearly.
}
\examples{

 a     <- c(1:10)
 dates1 <- as.Date(a, origin = '2017-01-01')
 count1 <- c(1,1,3,4,6,9,5,4,2,1)
 dat1   <- data.frame(dates1, count1)
 b     <- c(6:15)
 dates2 <- as.Date(b, origin = '2017-01-01')
 count2 <- c(1,2,4,5,6,9,3,4,1,1)
 dat2   <- data.frame(dates2, count2)
 EstimatorData(kernelest(dat1), estdist(dat2, returnonlyfunction = FALSE), Interpolate = TRUE, funcdatapoints = 50)

}
\seealso{
\code{scale}
}
\author{
Florian Berger <florian_berger@ymail.com>
}
